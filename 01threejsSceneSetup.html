
<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <style>

  	body {    
    background-image: url("https://i.imgur.com/0IWb7dn.gif");
     overflow:hidden;
}
div#fps {
    position: absolute;
    top: 0px;
    left: 0px;    
}
canvas{
   position: absolute;
    top: 0px;
    left: 0px;
}

  </style>




<script src="https://threejs.org/build/three.js"></script>  
<script src="https://threejs.org/examples/js/loaders/OBJLoader.js"></script>  


<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
  
</head>

<body>
<div id="fps" style="color:white;">
</div>
<div id = "container"></div>

</body>

<script>

window.addEventListener('keyup', function(event) { Key.onKeyup(event); }, false);
window.addEventListener('keydown', function(event) { Key.onKeydown(event); }, false);

	// document.addEventListener('keydown',onDocumentKeyDown,false);
	// document.addEventListener('keyup',onDocumentKeyUp,false);
	var elapsedTime = 0;
	var frameCount = 0;
	var lastTime = 0;

	lastTime = new Date().getTime();

	const WIDTH = 1920;
	const HEIGHT = 1080;

	const VIEW_ANGLE = 45;
	const ASPECT = WIDTH / HEIGHT;	
	const NEAR = 0.1;
	const FAR = 10000;

	const sphereMaterial = new THREE.MeshLambertMaterial({color: 0xCC0000});

	const pointLight = new THREE.PointLight(0xFFFFFF);

	// set its position
	pointLight.position.x = 10;
	pointLight.position.y = 50;
	pointLight.position.z = 130;

	//keyup down helper
	var Key = {
	  _pressed: {},
 		
 	  SPACE: 32, // JUMP

	  W: 87, // ^
	  A: 65, //  < 
	  S: 83, //  v
	  D: 68, // > 

	  LEFT: 37,
	  UP: 38,
	  RIGHT: 39,
	  DOWN: 40,	  

	  allUp: function() {
	  	return !(this._pressed[37])
	  	&& !(this._pressed[38])
	  	&& !(this._pressed[39])
	  	&& !(this._pressed[40])
	  	&& !(this._pressed[87])
	  	&& !(this._pressed[65])
	  	&& !(this._pressed[83])
	  	&& !(this._pressed[68])
	  },

	  isDown: function(keyCode) {
	    return this._pressed[keyCode];
	  },
	  
	  onKeydown: function(event) {
	    this._pressed[event.keyCode] = true;
	  },
	  
	  onKeyup: function(event) {
	    delete this._pressed[event.keyCode];
	  }
	};


	function Sphere(){
		
		var radius = 10;
		var segments = 16;
		var rings = 16;
		
		this.texture = new THREE.MeshLambertMaterial({color: 0xCC0000});

		this.obj = new THREE.Mesh(
			new  THREE.SphereGeometry(radius,
				segments,
				rings),

			this.texture)

		this.obj.position.z = -600;
		
		this.maxSpeed = 6;
		this.initSpeed = 1;
		this.xSpeed = this.initSpeed;
		this.ySpeed = this.initSpeed;
		this.jumpHeight = 1;
		this.maxJump = 5; 

	}


	Sphere.prototype.moveLeft = function() {
		this.accelerationX();
	  	this.obj.position.x -= this.xSpeed;
	};

	Sphere.prototype.moveRight = function() {
		this.accelerationX();
	 	this.obj.position.x += this.xSpeed;
	};

	Sphere.prototype.moveUp = function() {
		this.accelerationY();
	  	this.obj.position.y += this.ySpeed;
	};

	Sphere.prototype.moveDown = function() {
		this.accelerationY();
	  	this.obj.position.y -= this.ySpeed;
	};

	Sphere.prototype.jump = function(){

	}

	Sphere.prototype.decreaseSpeed = function(){	

	  	if (this.xSpeed > this.initSpeed)
	  	{
	  		this.xSpeed *= 0.85;
	  	}
	  	if (this.ySpeed > this.initSpeed)
	  	{
	  		this.ySpeed *= 0.85;
	  	}	  	
	
	}

	Sphere.prototype.accelerationX = function(x) {
		 	if(this.xSpeed < this.maxSpeed){
	  		this.xSpeed *= 1.05;
		  }
	}

	Sphere.prototype.accelerationY = function() {
		if(this.ySpeed < this.maxSpeed){
		this.ySpeed *= 1.1;
		} 
	}

	Sphere.prototype.jump = function (){
		if (this.jumpHeight < this.maxJump ) {
			this.jumpHeight *=  1.05		
		}
		else if ( this.jumpHeight > this.maxJump) 	{
			this.jumpHeight = -1.1; 
		}	

		if (this.jumpHeight < this.maxJump * -1 ){
			this.jumpHeight *= -0.85;
		}

		console.log(this.jumpHeight);

		this.obj.position.y += this.jumpHeight;
	}

	Sphere.prototype.update = function(){
		
		if (Key.isDown(Key.UP) || Key.isDown(Key.W) ) this.moveUp();
		if (Key.isDown(Key.LEFT) || Key.isDown(Key.A)) this.moveLeft();
		if (Key.isDown(Key.DOWN) || Key.isDown(Key.S)) this.moveDown();
		if (Key.isDown(Key.RIGHT) || Key.isDown(Key.D)) this.moveRight();
	  	
	  	if(Key.isDown(Key.SPACE)) this.jump();	  	

		if (Key.allUp()){ // no movement key is pressed
			this.decreaseSpeed();
		}

	  sphere.texture.color.setHex(gradientColorHEX(i));

	  //float up and down
		// sphere.obj.position.y += Math.sin(i);
	}

	const RADIUS = 50;
	const SEGMENTS = 16;
	const RINGS = 16;	

	var sphere = new Sphere();

	const container = document.querySelector('#container')

	const renderer = new THREE.WebGLRenderer( { alpha: true } );
	const camera = new THREE.PerspectiveCamera(
		VIEW_ANGLE,
		ASPECT,
		NEAR,
		FAR);

	var movementDirection = 1;
	var hexColor1 = 0x42eef4;
	var hexColor2 = 0x46f441;
	var i = 0;
	var frequency = .3;
	var amplitude = 127;
	var center = 128;


	//blue - purple gradient
	var color1 = [66,232,244]; // BLUE
	var color2 = [204,10,181]; // Green


function fpsDisplay(){
		  var now = new Date().getTime();
	  frameCount++;
		  elapsedTime += (now - lastTime);

	lastTime = now;

	if(elapsedTime >= 1000) {
	   fps = frameCount;
	   frameCount = 0;
	   elapsedTime -= 1000;

	   document.getElementById('fps').innerHTML = fps;
	}
}

function wait(ms){
   var start = new Date().getTime();
   var end = start;
   while(end < start + ms) {
     end = new Date().getTime();
  }
}


function colorGradient() {
	
	if (movementDirection > 0)
	{
		return hexColor1;
	}
	else
	{
		return hexColor2;
	}
}


function byte2Hex(n)
  {
    var nybHexString = "0123456789ABCDEF";
    return String(nybHexString.substr((n >> 4) & 0x0F,1)) + nybHexString.substr(n & 0x0F,1);
  }

 function RGB2Color(r,g,b)
  {
    return '0x' + byte2Hex(r) + byte2Hex(g) + byte2Hex(b);
  }

function refreshGlobalVariables(){
		i+= 0.1;
}

function midRGB(){

	var rgb = [0,0,0];

	 rgb[0] = ((color1[0] + color2[0]) / 2);
	 rgb[1] = ((color1[1] + color2[1]) / 2);
	 rgb[2] = ((color1[2] + color2[2]) / 2);
	
	return rgb;
}

function colorAmplitude(){
	return midRGB();
}

function gradientColorRGB(i){
	var frequency = .25;

//https://stackoverflow.com/questions/5731863/mapping-a-numeric-range-onto-another
// slope = (output_end - output_start) / (input_end - input_start)
// output = output_start + slope * (input - input_start)

	var slope = [(color1[0] - color2[0]) / (3-1)
	, (color1[1] - color2[1]) / (3-1)
	, (color1[2] - color2[2]) / (3-1)];

//	var outputTST = color2[0] + slope[0] * (1.5 - 1);

	var rgb = [color2[0] + slope[0] * ( (Math.sin(i * frequency)+2) - 1)
	, color2[1] + slope[1] * ( (Math.sin(i * frequency)+2) - 1)
	, color2[2] + slope[2] * ( (Math.sin(i * frequency)+2) - 1)];

	return rgb;
}


function gradientColorHEX(i)
{
	return rgbToHex(gradientColorRGB(i));
}

function rgbToHex(rgb){
	var hex = '0x' + byte2Hex(rgb[0]) + byte2Hex(rgb[1]) + byte2Hex(rgb[2]);
	
	return hex;
}


function byte2Hex(n)
  {
    var nybHexString = "0123456789ABCDEF";
    return String(nybHexString.substr((n >> 4) & 0x0F,1)) + nybHexString.substr(n & 0x0F,1);
  }


	const scene = new THREE.Scene();

	// add to the scene
	scene.add(pointLight);

	scene.add(sphere.obj);

	scene.add(camera);

	renderer.setSize(WIDTH, HEIGHT);

	container.appendChild(renderer.domElement);

	renderer.render(scene,camera);

	requestAnimationFrame(gameloop);


	function gameloop ()
	{	

		fpsDisplay();

		refreshGlobalVariables();		
		
		sphere.update();
		
		renderer.render(scene, camera);

		// Schedule the next frame.
		requestAnimationFrame(gameloop);

	}



  </script>
  
</html>
