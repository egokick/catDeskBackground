
<!doctype html>
<head>
 <meta charset="utf-8">
<link rel="icon" type="image/png" href="favicon-32x32.png" sizes="32x32" />
 <link rel="stylesheet" type="text/css" href="style.css">

<!-- Libaries --> 
<script src="lib/three.js"></script>  
<script src="lib/OBJLoader.js"></script>
<script src="lib/OrbitControls.js"></script>
<script src="lib/dat.gui.js"></script>
<script src="lib/tween.js"></script>


<!-- Color Helper--> 
<script src="helper/colorHandler.js"></script>
<script src="helper/Mobility.js"></script>


<!-- Scene Objects -->
<script src="/Objects/Sphere.js"></script>
<script src="/Objects/Cat.js"></script>


<!-- Controls -->
<script src="helper/wasd.js"></script>

<!-- Interface -->
<script src="helper/fps.js"></script>

</head>

<body>

<div id="fps"></div>
<div id="container"></div>

</body>

<script>

	var controls = new function () {
	 
	 // set to 0.01 to make sure dat.gui shows correct output
	 this.influence1 = 0.01;
     this.influence2 = 0.01;
	 
	 this.update = function () {
		sphere.obj.morphTargetInfluences[0] = controls.influence1;		 		 		
	 };

}
	// gui.add(controls, 'influence1', 0.0, 1.0).onChange(controls.update);;	



	var i = 0;
	var sphere = new Sphere();
	// sphere.obj.geometry.computeMorphNormals();

	const pointLight = new THREE.PointLight(0xFFFFFF);

	// set its position
	pointLight.position.x = 10;
	pointLight.position.y = 50;
	pointLight.position.z = 130;
 	
 	displayGUI();

	const WIDTH = 1920;
	const HEIGHT = 1080;
	const VIEW_ANGLE = 45;
	const ASPECT = WIDTH / HEIGHT;	
	const NEAR = 0.1;
	const FAR = 10000;

	const scene = new THREE.Scene();
	const renderer = new THREE.WebGLRenderer( { alpha: true } );
	
	renderer.shadowMapEnabled = true;
	
	// const camera = new THREE.PerspectiveCamera(
	// 	VIEW_ANGLE,
	// 	ASPECT,
	// 	NEAR,
	// 	FAR);

const camera = new THREE.OrthographicCamera( WIDTH / - 6 //left
 	, WIDTH / 6//right
 	, HEIGHT / 6 //top
 	, HEIGHT / - 6 //bottom
 	, -200 //near
 	, 500  //far
 	, -1//zoom
 	);

	// add to the scene
	scene.add(pointLight);
	scene.add(sphere.obj);
	scene.add(camera);
	renderer.setSize(WIDTH, HEIGHT);
	document.getElementById("container").appendChild(renderer.domElement)
	renderer.render(scene,camera);
	requestAnimationFrame(gameloop);


	// var posSrc = {pos: 1};

	// var tween = new TWEEN.Tween(posSrc).to({pos: 0}, 5000);
	// tween.easing(TWEEN.Easing.Sinusoidal.InOut);

	// var tweenBack = new TWEEN.Tween(posSrc).to({pos: 1}, 5000);
	// tweenBack.easing(TWEEN.Easing.Sinusoidal.InOut);

	// tween.chain(tweenBack);
	// tweenBack.chain(tween);

	// var tween = new TWEEN.Tween({x: 10}).to({x: 3},
	//  10000).easing(TWEEN.Easing.Elastic.InOut).onUpdate( function ()
	//  {
	// 	objectsUpdate(); // update the mesh
	// })


	var fun = 0 
	function objectsUpdate(){
		
		var count = 0;
		var pos = this.pos;

		sphere.move.update();

		// if (fun < sphere.obj.geometry.vertices.length - 55){		
		// 	if (sphere.obj.geometry.vertices[fun].x > 40 ||  sphere.obj.geometry.vertices[fun].x <-40){fun += 33}

		// 	for(i=fun;i<fun+12;i++){
		// 		sphere.obj.geometry.vertices[i].x -= 1.7
		// 		sphere.obj.geometry.vertices[i].z +=  2.7
		// 		sphere.obj.geometry.vertices[i].y -=  1
		// 	}
		// }

		// sphere.obj.geometry.verticesNeedUpdate = true;
		// sphere.texture.color.setHex(gradientColorHEX(i));
		
		// sphere.obj.geometry.computeFaceNormals() 
		// sphere.texture.needsUpdate = true;
		// sphere.obj.geometry.colorsNeedUpdate = true;

		if(isCatLoaded) cat.move.update();
	}

	function gameloop ()
	{			
		fpsDisplay();
		refreshGlobalVariables();		
		
		objectsUpdate();

		renderer.render(scene, camera);	
		requestAnimationFrame(gameloop);

	}
	console.log(sphere)



  </script>
  
</html>

